#pragma once

#include <string>
#include <vector>
#include <vulkan/vulkan.h>

#include "resource.h"
#include "resource_manager.h"

// the render graph consists of a timeline of instructions - either cameras to draw, or post process steps to run
// each command will have inputs and outputs which read from and write to buffers
// those buffers can then be used as the inputs/outputs of other commands
// one buffer is the framebuffer, and can only be written to once
// cameras will output colour, depth, and extra buffers, and you can choose which you want to keep in buffers
// then any of those can be bound to inputs on post process steps, which can also have multiple outputs

/*
     buf a          buf b        framebuffer
       ^              ^               ^
|      |       |      |       |       |        |
| render cam 1 | render cam 2 | post process 1 |
|              |              |    ^       ^   |
                                   |       |
                                 buf a   buf b
*/

// TODO: support custom render pass with different output attachments
struct PTRGStep
{
    int colour_buffer_binding = 0;
    int depth_buffer_binding = -1;
    int normal_buffer_binding = -1;
    int extra_buffer_binding = -1;

    bool is_camera_step = true;
    size_t camera_slot = 0;

    PTMaterial* process_material;
    std::vector<std::pair<int, uint16_t>> process_inputs;
};

class PTRGGraph
{
    friend class PTResourceManager;
private:
    VkDevice device = VK_NULL_HANDLE;

    std::vector<PTRGStep> timeline_steps;
    std::vector<std::pair<PTImage*, VkImageView>> image_buffers;

    PTImage* spare_colour_image = nullptr;
    VkImageView spare_colour_image_view = VK_NULL_HANDLE;
    PTImage* spare_depth_image = nullptr;
    VkImageView spare_depth_image_view = VK_NULL_HANDLE;
    PTImage* spare_normal_image = nullptr;
    VkImageView spare_normal_image_view = VK_NULL_HANDLE;
    PTImage* spare_extra_image = nullptr;
    VkImageView spare_extra_image_view = VK_NULL_HANDLE;

    PTRGGraph(VkDevice _device, std::string timeline_path);
    ~PTRGGraph();

public:

    
    // should manage the buffers and steps required
    // minimise the extra code required by render server
    // simplify render server to have a function to draw into a provided buffer, not just the framebuffer
    // drawframe should instead mostly focus on managing timing etc
    // render graph should be able to generate command queues maybe?
    // captures the output buffers generated by rendering and copies them into the relevant buffers inside graph? or uses the relevant graph buffers
};